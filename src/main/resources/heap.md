# 堆

## 什么是堆

堆需要满足以下2个特征：

* 堆是一个完全二叉树

> 解释：完全二叉树要求，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。
  
* 堆中的每个节点的值都必须大于等于（或者小于等于）其子树中的每个节点的值

> 解释：堆中每个节点的值都大于等于（或者小于等于）其左右子节点的值。

堆分为2种：

* 大顶堆(MaxHeap)：每个节点的值大于等于子树中的每个节点值

* 小顶堆(MinHeap)：每个节点的值小于等于子树中的每个节点值

```
//大顶堆

      10
     /  \
    9    8
   / \  / \
  6  5 7   4 
 /
3

//小顶堆

      3
     /  \
    4    6
   / \  / \
  5  8 9  10
 /
7

//不是堆

      3
     /  \
    4    6
   / \  / \
  5  8 9  10
   \
   7 
```

## 如何存储一个堆

完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的，因为不需要用多余的空间来存储指向左右子节点的指针。

示例如下：

```
//以下是一个堆，括号内数字表示元素在数组中的下标

      10(1)
     /     \
    9(2)   8(3)
   /   \    /
  6(4) 5(5) 7(6) 

数组：x 10 9 8 6 5 7（从数组下标1开始存储数据，下标0的元素用"x"表示空）
下标：0 1  2 3 4 5 6
```

可以看出，我们从数组下标1开始存储数据，数组中下标为`i`的节点的左子节点的下标是`i*2`，右子节点的下标是`i*2+1`，父节点的下标是`i/2`。
例如上图中下标2的节点的左子节点下标为4，右子节点的下标为5，父节点的下标为1。

## 堆的操作

### 往堆中插入一个元素

往堆中插入一个元素，需要继续满足"堆"的两个特征。

如果把新插入的元素放到堆的最后，则可能就不再符合"堆"的特征，需要进行调整来重新满足堆的特征，这个过程叫做*堆化*(heapify)，堆化分2种：从下往上和从上往下

```
//以新插入元素"11"为例，把11放在堆的最后，很显然不符合堆的特征

      10(数组下标：1)
     /      \
    9(2)     8(3)
   /   \     /  \
  6(4) 5(5) 7(6) 11(7)
                   ^

数组：x 10 9 8 6 5 7 11
下标：0 1  2 3 4 5 6 7
```

堆化的过程（以大顶堆为例）：新插入的节点与父节点对比大小，如果大于父节点则互换两个节点，一直重复这个过程直到满足大小关系（子节点小于等于父节点），这就是从下往上的堆化方法。

```
//以新插入元素"11"为例，进行堆化：

      10(数组下标：1)
     /      \
    9(2)     8(3)
   /   \     /  \
  6(4) 5(5) 7(6) 11(7)
                   ^
//新节点11大于父节点8，交换：

      10(数组下标：1)
     /      \
    9(2)     11(3)
   /   \     /  \
  6(4) 5(5) 7(6) 8(7)
  
//新节点11大于父节点10，交换：

      11(数组下标：1)
     /      \
    9(2)     10(3)
   /   \     /  \
  6(4) 5(5) 7(6) 8(7)
  
堆化结束

```

代码示例：

```java
public class Heap {

    private int[] a;    //数组，从下标1开始存储数据
    private int max;    //堆中可以存储的最大数据个数
    private int count;  //堆中已经存储的数据个数

    public Heap(int capacity) {
        //堆的初始化
        a = new int[capacity + 1];
        max = capacity;
        count = 0;
    }

    //新插入的元素放到堆的最后，然后进行"堆化"
    //堆化的过程（以大顶堆为例）：新插入的节点与父节点对比大小，如果大于父节点则互换两个节点，
    //一直重复这个过程直到满足大小关系（子节点小于等于父节点）
    public void insert(int data) {
        if (count >= max) return;   //堆满了
        ++count;
        a[count] = data;            //新插入的元素放到数组最末尾，堆的最后
        int i = count;
        while (i/2 > 0 && a[i] > a[i/2]) {  //新插入的节点值大于父节点值
            swap(a, i, i/2);        //交换下标i和i/2的元素
            i = i/2;
        }
    }
}

```

### 删除堆顶元素

以大顶堆为例，当把堆顶元素（即最大的元素）删除之后，就需要把第二大的元素放到堆顶，那么第二大的元素肯定在左右子节点中。然后再迭代删除第二大的节点，
依次类推直到叶子节点被删除。

示例如下：

```
//删除堆顶元素27
             
    27            
   /  \       
  16   13    
 / \   / \
5   6 7   8 

//第二大的元素是16，把16放到堆顶

    16           
   /  \       
  x    13    
 / \   / \
5   6 7   8 

//原来元素16所在位置空缺（x），其左右子节点中6较大，把6放到x位置

    16           
   /  \       
  6    13    
 /     / \
5     7   8 

```

从以上例子可以看出，这种方法会导致一个问题，最终堆化出来的堆并不一定满足堆的特征（不是完全二叉树）。

可以通过换一种思路解决这个问题：

删除堆顶元素后，把堆的最后一个元素放至堆顶，然后利用同样的父子节点对比，对于不满足父子节点关系的，互换节点位置，并且重复这个过程，直到父子节点之间满足大小关系为止，这就是从上往下的堆化方法。

同样以刚才的堆为例：

```
//删除堆顶元素27

    27           
   /  \       
  16   13    
 / \   / \
5   6 7   8 

//把堆的最后一个元素8放至堆顶

    8          
   /  \       
  16   13    
 / \   / 
5   6 7    

//从上而下堆化，8和其左右子节点对比，16和8互换位置

    16          
   /  \       
  8    13    
 / \   / 
5   6 7 

//8和其左右子节点对比，满足父子节点大小关系（8大于5和6），堆化结束

    16          
   /  \       
  8    13    
 / \   / 
5   6 7 
```

以上方法中，因为移除的是堆的最后一个元素，之后的堆化过程都是在交换元素位置，所以最后的结果一定还是一个堆。

代码示例：

```java 
//删除堆顶元素（已大顶堆为例），即删除最大值
public void removeMax() {
    if (count == 0) return;
    a[1] = a[count];    //把最后一个元素移至堆顶
    --count;
    heapify(a, count, 1);
}

//从上而下堆化
//下标为i的当前节点的左子节点的下标为i*2，右子节点的下标为i*2+1
private void heapify(int[] a, int n, int i) {
    while (true) {
        int maxPos = i;
        if (i*2 <= n && a[i] < a[i*2]) maxPos = i*2;    //如果左子节点大，记录maxPos为左子节点下标
        if (i*2+1 <= n && a[maxPos] < a[i*2+1]) maxPos = i*2+1; //如果右子节点更大，记录maxPos为右子节点下标
        if (maxPos == i) break; //对比完左右子节点，若maxPos没有发生变化，则说明当前节点比左右子节点都大，则直接跳出
        //否则，交换
        swap(a, i, maxPos);
        i = maxPos;
    }
}

private void swap(int[] a, int i, int j) {
    int tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
}
```

由于一个包含n个节点的完全二叉树，树的高度不会超过log<sub>2</sub>n，而堆化的过程都是顺着节点的路径进行比较和交换，所以堆化的时间复杂度应该跟树的高度成正比，也就是O(logn)，所以在堆中插入一个元素和删除堆顶元素的时间复杂度都是O(logn)。

## 堆排序

借助堆这种数据结构实现排序算法，叫做堆排序，这种排序的时间复杂度非常稳定，是O(nlogn)，并且它是一种原地排序算法。

排序的过程分为2步：建堆 -> 排序

### 建堆

首先第一步是建堆，可以不借助另一个数组，完成"原地"建堆的，有2种思路，第一种思路是从前往后处理数据，从下往上的堆化过程；第二种思路是从后往前处理数据，从上往下堆化：

1. 借助堆中插入一个元素的思路，假设起始堆中只包含了一个数据，就是下标为1的数据。然后我们把下标从2到n的数据依次插入堆中，这样就完成了建堆过程

2. 从后往前处理数组数据，从第一个非叶子节点开始，依次堆化

示例如下：

```
以第二种思路为例：

数组：x 7 5 19 8 4 1 20 13 16
下标：0 1 2 3  4 5 6 7  8  9
  
//从后往前，第一个非叶子节点是下标为4的元素8    

      7(1)
     /    \
    5(2)    19(3)
   /    \    /  \
  8(4) 4(5) 1(6) 20(7)
 /   \
13(8) 16(9)

//从元素8，从上而下堆化，和它的右子节点16进行交换

      7(1)
     /    \
    5(2)   19(3)
   /    \    /  \
  16(4) 4(5) 1(6) 20(7)
 /   \
13(8) 8(9)

//下一个非叶子节点是下标为3的元素19，和它的右子节点20进行交换

     7(1)
     /    \
    5(2)   20(3)
   /    \    /  \
  16(4) 4(5) 1(6) 19(7)
 /   \
13(8) 8(9)

//下一个非叶子节点是下标为2的元素5，5和16交换，5再和13交换

     7(1)
     /    \
    16(2)   20(3)
   /    \    /  \
  13(4) 4(5) 1(6) 19(7)
 /   \
5(8) 8(9)

//最后一个非叶子节点是下标为1的元素7，7和20交换，7再和19交换

     20(1)
     /    \
    16(2)   19(3)
   /    \    /  \
  13(4) 4(5) 1(6) 7(7)
 /   \
5(8) 8(9)

最后堆化完成后的数组变为：x 20 16 19 13 4 1 7 5 8

```

代码示例：

先解决一个问题，从后往前，第一个非叶子节点下标是多少？

因为堆是完全二叉树，最后一层的叶子节点是靠左的，所以堆的最后一个叶子就是数组的最后一个元素，最后一个元素下标为n，它的父节点下标为n/2，也是最后一个非叶子节点。

所以，从下标n/2到1的都是非叶子节点，对下标n/2到1的数据进行堆化，从下标n/2+1到n的节点都是叶子节点，我们不需要堆化。

```java
//从数组"原地"构建堆
private void buildHeap(int[] a, int n) {
    //最后一个非叶子节点下标一定为n/2
    for (int i = n/2; i >= 1; i--) {
        heapify(a, n, i);   //该方法参考上面从上而下的堆化方法
    }
}
```

由于每个节点堆化的时间复杂度是O(logn)，那么n/2个节点堆化的总时间复杂度就是O(nlogn)？其实这个答案不够精准，具体推导如下：（待完善）

### 排序

建堆完成后，其实堆顶的就已经是最大元素，把它跟最后一个元素交换，把最大元素放到下标为n的位置。这个思路有点像"删除堆顶的元素"，把堆顶元素和下标n的元素交换位置，
然后再将剩余n-1（下标1到n-1）个元素进行堆化，堆化完成后，再将堆顶元素和下标n-1的元素交换位置，一直重复这个过程，直到最后堆中只有下标为1的一个元素，排序完成。

```
拿上一个建堆完成的数组为例：

数组：x 20 16 19 13 4 1 7 5 8
下标：0 1  2  3  4  5 6 7 8 9

     20(1)
     /    \
    16(2)   19(3)
   /    \    /  \
  13(4) 4(5) 1(6) 7(7)
 /   \
5(8) 8(9)

//把堆顶元素20，和最后一个元素（下标为9）8交换

      8(1)
     /    \
    16(2)   19(3)
   /    \    /  \
  13(4) 4(5) 1(6) 7(7)
 /   \
5(8) 20(9)

//重新开始堆化，8和19交换，堆化结束

      19(1)
     /    \
    16(2)   8(3)
   /    \    /  \
  13(4) 4(5) 1(6) 7(7)
 /   \
5(8) 20(9)

//把堆顶元素19，和下标为8的元素5交换

      5(1)
     /    \
    16(2)   8(3)
   /    \    /  \
  13(4) 4(5) 1(6) 7(7)
 /   \
19(8) 20(9)

//重新开始堆化，5和16交换，5和13交换，堆化结束

      16(1)
     /    \
    13(2)   8(3)
   /    \    /  \
  5(4) 4(5) 1(6) 7(7)
 /   \
19(8) 20(9)

//把堆顶元素16，和下标为7的元素7交换

      7(1)
     /    \
    13(2)   8(3)
   /    \    /  \
  5(4) 4(5) 1(6) 16(7)
 /   \
19(8) 20(9)

//重新开始堆化，7和13交换，堆化结束

      13(1)
     /    \
    7(2)   8(3)
   /    \    /  \
  5(4) 4(5) 1(6) 16(7)
 /   \
19(8) 20(9)

//把堆顶元素13，和下标为6的元素1交换

      1(1)
     /    \
    7(2)   8(3)
   /    \    /  \
  5(4) 4(5) 13(6) 16(7)
 /   \
19(8) 20(9)

//重新开始堆化，1和8交换，堆化结束

      8(1)
     /    \
    7(2)   1(3)
   /    \    /  \
  5(4) 4(5) 13(6) 16(7)
 /   \
19(8) 20(9)

//把堆顶元素8，和下标为5的元素4交换

      4(1)
     /    \
    7(2)   1(3)
   /    \    /  \
  5(4) 8(5) 13(6) 16(7)
 /   \
19(8) 20(9)

//重新开始堆化，4和7交换，4和5交换，堆化结束

      7(1)
     /    \
    5(2)   1(3)
   /    \    /  \
  4(4) 8(5) 13(6) 16(7)
 /   \
19(8) 20(9)

//把堆顶元素7，和下标为4的元素4交换

      4(1)
     /    \
    5(2)   1(3)
   /    \    /  \
  7(4) 8(5) 13(6) 16(7)
 /   \
19(8) 20(9)

//重新开始堆化，4和5交换，堆化结束

      5(1)
     /    \
    4(2)   1(3)
   /    \    /  \
  7(4) 8(5) 13(6) 16(7)
 /   \
19(8) 20(9)

//把堆顶元素5，和下标为3的元素1交换

      1(1)
     /    \
    4(2)   5(3)
   /    \    /  \
  7(4) 8(5) 13(6) 16(7)
 /   \
19(8) 20(9)

//重新开始堆化，1和4交换，堆化结束

      4(1)
     /    \
    1(2)   5(3)
   /    \    /  \
  7(4) 8(5) 13(6) 16(7)
 /   \
19(8) 20(9)

//把堆顶元素4，和下标为2的元素交换，结束排序

      1(1)
     /    \
    4(2)   5(3)
   /    \    /  \
  7(4) 8(5) 13(6) 16(7)
 /   \
19(8) 20(9)

最终排序后的数组：x 1 4 5 7 8 13 16 19 20

```

代码示例：

```java
public void sort(int[] a, int n) {
    buildHeap(a, n);
    int i = n; //从最后一个开始
    while (i>1) {
        swap(a, 1, i); //和堆顶元素交换
        --i;
        heapify(a, i, 1);//从堆顶元素开始堆化
    }
}
```

## 堆排序的时间复杂度、空间复杂度、稳定性的分析

### 稳定性

排序过程中，存在将堆最后的一个节点和堆顶节点交换，有可能改变值相同元素的原始顺序，所以堆排序不是稳定的排序算法。

### 空间复杂度

整个排序过程，只有交换元素的才会借助临时存储空间，所以是原地排序算法。

### 时间复杂度

至于时间复杂度，从以上代码可以看出，排序包括建堆和N次堆化组成：

```
public void sort(int[] a, int n) {
    buildHeap(a, n);                        -> 时间复杂度O(n)
    int i = n; //从最后一个开始
    while (i>1) {                           -> 循环n-1次的交换元素和堆化，O(nlogn)
        swap(a, 1, i); //和堆顶元素交换
        --i;
        heapify(a, i, 1);//从堆顶元素开始堆化 -> 堆化时间复杂度O(logn)
    }
}
```

所以最终的时间复杂度是O(nlogn)
