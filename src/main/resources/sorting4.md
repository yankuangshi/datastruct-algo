# 排序优化（Sorting Optimization）

## 0x0 如何选择合适的排序算法

回顾下讲过的几种排序算法

||时间复杂度|是否稳定排序|是否原地排序
|:---:|:---:|:----:|:----:|
|冒泡排序|O(n<sup>2</sup>|Y|Y|
|插入排序|O(n<sup>2</sup>|Y|Y|
|选择排序|O(n<sup>2</sup>|N|Y|
|归并排序|O(nlogn)|Y|N|
|快速排序|O(nlogn)|N|Y|
|桶排序|O(n)|Y|N|
|计数排序|O(n+k)k是数据范围|Y|N|
|基数排序|O(dn)d是维度|Y|N|

1. 如果要写一个通用的排序函数，不能选择线性排序算法，因为适用场景比较特殊（对数据比较苛刻）
2. 如果对小规模数据排序，可以选择时间复杂度O(n<sup>2</sup>)的算法
3. 如果对大规模数据排序，O(nlogn)的算法更加高效，所以为了兼顾任意规模数据的排序，一般首选O(nlogn)的排序算法

归并排序和快排在平均情况下都是O(nlogn)，而且快排在最坏情况下时间复杂度是O(n<sup>2</sup>)，为什么归并排序还不被"宠幸"，因为：

归并排序不是原地排序，空间复杂度是O(n)，如果要排序100MB的数据，除了数据本身占用的内存外，还要额外再占用100MB的内存空间

## 0x1 优化快速排序

快排之所有会出现时间复杂度O(n<sup>2</sup>)的最坏情况是因为*分区点选的不够合理*，最理想的分区点事：*被分区点分开的两个分区中，数据的数量差不多*。
如果很粗暴地直接选择第一个或者最后一个数据作为分区点，不考虑数据的特点，肯定在某些情况下会出现最坏情况

优化分区点的方法：

#### 0x11 三数取中法

从区间的首、尾、中间，分别取出一个数，对比大小，取3个数的中间值作为pivot。但是如果要排序的数组比较大，那"三数取中"可能就不够了，可能要"五数取中"或"十数取中"。

#### 0x12 随机法

每次从要排序的区间中，随即选择一个元素作为pivot，这种方法没法保证每次分区点都选的比较好，但是从概率角度来看，也不大可能每次分区点都很差的情况

## 0x2 举例分析排序函数

拿glibc中的`qsort()`函数源码举例说明：

1. `qsort`会*优先使用归并排序*，因为归并排序空间复杂度是O(n)，所以对于小数据量的排序，如1KB、2KB等，归并排序额外需要1KB、2KB的内存空间，这个问题不大，这也是*空间换时间*的思想。
但如果数据量太大，`qsort`会*改为用快排算法来排序*。
2. `qsort`选择分区点的方法就是"三数取中点"的方法。
3. 在快速排序的过程中，当要排序的区间中，元素个数小于等于4时，`qsort`就退化为插入排序，因为*O(n<sup>2</sup>)时间复杂度的算法不一定比O(nlogn)的算法执行时间长*
    
    例如：k=1000，c=200时，对小规模数据n=100排序时，n<sup>2</sup>的值实际上比`knlogn+c`还要小
    
    ```
    knlogn+c = 1000 * 100 * log100 + 200 远大于 10000
    
    n^2 = 100*100 = 10000
    ```
    
    