# 栈（Stack）

1. 栈的特征，后进先出，先进后出（FILO：FIRST IN LAST OUT）
2. 栈是一种“操作受限”的线性表，只允许在栈顶插入和删除数据

## 为什么需要栈

1. 功能上来说，数组和链表可以替代栈，但是特定的数据结构是对特定场景的抽象，数组和链表暴露了太多操作接口，灵活的同时也不可控，容易出错
2. 当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出的特性，应该考虑首选"栈"

## 实现一个"栈"

2个操作：入栈、出栈

```java
public class Stack<T> {
    //压栈
    public void push(T data){}
    //出栈
    public T pop(){}
    //是否为空
    public boolean isEmpty(){}
    //栈中元素个数
    public int size(){}
    //返回栈顶数据但不出栈
    public T peek(){}
}
```

* 数组实现的栈：顺序栈
* 链表实现的栈：链式栈

## 分析空间复杂度、时间复杂度

入栈和出栈过程，只需要一两个临时变量存储空间，所以空间复杂度是O(1)；入栈和出栈只涉及栈顶个别数据，所以时间复杂度是O(1)

## 支持动态扩容的顺序栈

实现一个支持动态扩容的栈，需要底层依赖一个支持动态扩容的数组，当栈满了以后，申请一个更大的数组，将原来的数据搬移到新数组中

## 分析支持动态扩容的顺序栈的入栈、出栈时间复杂度

1. 对于出栈，不会涉及内存的重新申请和数据搬移，所以时间复杂度仍然是O(1)
2. 对于入栈，当栈中有空闲空间时，时间复杂度是O(1)；但当空间不足时，需要重新申请内存和数据搬移，时间复杂度变成O(n)

## 栈的应用

### 函数调用中的应用（函数调用栈）

操作系统给每个线程分配一块独立的内存空间，这块内存被组织成"栈"这种结构，用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，
当被调用的函数执行完成返回之后，将这个函数对应的栈帧出栈

示例如下：

```c++
int main() {
   int a = 1; 
   int ret = 0;
   int res = 0;
   ret = add(3, 5);
   res = a + ret;
   printf("%d", res);
   reuturn 0;
}

int add(int x, int y) {
   int sum = 0;
   sum = x + y;
   return sum;
}
```

```
    |_ ... _|
    |_sum=0_| ---
    |__x=3__|   add栈桢
    |__y=5__| ---
    |_ ... _| ---
    |_res=0_|   main栈桢
    |_ret=0_|
    |__a=1__| ---   
```

### 表达式求值中的应用

比如：`34+13*9+44-12/3`这个四则运算计算机是如何来实现计算的

编译器通过2个栈来实现，其中一个栈保存操作数，另一个栈保存运算符，从左到右遍历表达式，当遇到数字直接压入操作数栈；

遇到运算符，与运算符栈的栈顶元素进行比较：

1. 如果比栈顶的运算符优先级高，把当前运算符压入栈
2. 如果比栈顶的运算符优先级低或者相同，栈顶运算符出栈，同时从操作数栈中取2个操作数，进行计算，再把计算结果压入操作数栈，继续比较

示例如下：`3+5*8-6`

```
Step1：
|___|     |___|
|___|     |___|
|___|     |___|
|_3_|     |___|
操作数栈   运算符栈

Step2：
|___|     |___|
|___|     |___|
|___|     |___|
|_3_|     |_+_|

Step3：
|___|     |___|
|___|     |___|
|_5_|     |___|
|_3_|     |_+_|

Step4：'*'优先级比'+'高，压栈
|___|     |___|
|___|     |___|
|_5_|     |_*_|
|_3_|     |_+_|

Step5：
|___|     |___|
|_8_|     |___|
|_5_|     |_*_|
|_3_|     |_+_|

Step6：'-'比'*'优先级地，出栈'*'，取出操作数8和5计算得40，重新入栈
|___|     |___|
|___|     |___|
|_40|     |___|
|_3_|     |_+_|

Step7：'-'和'+'优先级相同，出栈'+'，取出操作数40和3计算得43，重新入栈
|___|     |___|
|___|     |___|
|___|     |___|
|_43|     |___|

Step8：'-'入栈
|___|     |___|
|___|     |___|
|___|     |___|
|_43|     |_-_|

Step9：
|___|     |___|
|___|     |___|
|_6_|     |___|
|_43|     |_-_|

Step10：清空栈，得43-6=37
|___|     |___|
|___|     |___|
|___|     |___|
|___|     |___|
```

### 括号匹配中的应用

可以借助栈来检查表达式中括号是否匹配，假设表达式只会包含3种括号，圆括号`()`、方括号`[]`、花括号`{}`

可以用栈来保存未匹配的左括号，从左向右遍历表达式，当扫描到左括号，则将其压入栈；当扫描到右括号，从栈顶取出左括号，如果能匹配则继续扫描剩下的表达式，如果无法匹配则说明非法格式

## 思考

1. 如何实现浏览器的前进后退功能

    用2个栈，X和Y，把首次浏览的页面依次压入栈X，当点击后退时，再依次从栈X中出栈，把出栈的数据压入栈Y；当点击前进时，依次从栈Y出栈，放入栈X；
    当栈X中没有数据时，说明没有页面可以继续后退浏览了；当栈Y中没有数据时，说明没有页面可以继续前进了

2. 我们在讲栈的应用时，讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？
    
    从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。
    而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。

3. 我们都知道，JVM 内存管理中有个“堆栈”的概念。栈内存用来存储局部变量和方法调用，堆内存用来存储 Java 中的对象。那 JVM 里面的“栈”跟我们这里说的“栈”是不是一回事呢？如果不是，那它为什么又叫作“栈”呢？

    内存中的堆栈和数据结构堆栈不是一个概念，内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。
    
## 栈相关代码练习

* 有效的括号 [LeetCode 20](https://leetcode-cn.com/problems/valid-parentheses/)
* 最小栈 [LeetCode 155](https://leetcode-cn.com/problems/min-stack/)
* 用栈实现队列 [LeetCode 232](https://leetcode-cn.com/problems/implement-queue-using-stacks/)
* 比较含退格的字符串 [LeetCode 844](https://leetcode-cn.com/problems/backspace-string-compare//)
* 基本计算器 [LeetCode 224](https://leetcode-cn.com/problems/basic-calculator/)
