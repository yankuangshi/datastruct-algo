# 排序(1)（Sorting）

## 0x0 如何分析一个"排序算法"

从以下几方面分析：

1. 排序算法的执行效率
    
    1. 最好情况、最坏情况、平均情况时间复杂度
    2. 时间复杂度的系数、常数、低阶（在实际开发中，排序的可能是10个、100个、1000个这样的小规模数据，所以需要把这些因素考虑进来）
    3. 比较次数和交换（或移动）次数

2. 排序算法的内存消耗

    *原地排序*（Sorted in place），特指空间复杂度是O(1)的排序算法

3. 排序算法的稳定性

    *稳定性*，这个概念是说，如果待排序的序列中存在值相等的元素，经过排序后，相等元素的原有先后顺序不变
    
    比如：2、9、3、4、8、3 排序完成后变成 2、3、3、4、8、9，这组数据里有两个3，经过某种排序算法之后，两个3的前后顺序没有发生变化，这种排序算法
    称为*稳定的排序算法*；如果两个3的前后顺序发生了改变，对应的排序算法叫做*不稳定的排序算法*
    
    稳定性重要性：可针对对象的多种属性进行优先级排序

举例：对电商交易系统中的"订单（order）"排序，订单有2个属性，下单时间（create_time）和订单金额（money），如果有10万条订单记录，希望
按订单金额从小到大排序，对与金额相同的订单，希望按下单时间从早到晚排序

如果先按金额对订单排序，然后再遍历订单，对每个金额相同的小区间再按照下单时间排序，这种思路理解起来不难但是实现会很复杂

换个思路：先按下单时间排序，之后利用稳定排序算法按金额重新排序，最终的排序结果正是我们所需要的，因为*稳定排序算法可以保持金额相同的两个对象在排序之后的前后顺序不变*

示例如下：

先按下单时间排序：

|ID     |create_time    |money  |
|:-----:|:-------------:|:-----:|
|1      |2019-3-1 08:00 |50     |
|2      |2019-3-1 09:01 |30     |
|3      |2019-3-1 10:02 |40     |
|4      |2019-3-1 11:03 |30     |
|5      |2019-3-1 12:04 |30     |
|6      |2019-3-1 13:05 |60     |

按金额重新排序（稳定排序算法）：

|ID     |create_time    |money  |
|:-----:|:-------------:|:-----:|
|1      |2019-3-1 09:01 |30     |
|2      |2019-3-1 11:03 |30     |
|3      |2019-3-1 12:04 |30     |
|4      |2019-3-1 10:02 |40     |
|5      |2019-3-1 08:00 |50     |
|6      |2019-3-1 13:05 |60     |


## 0x1 常见排序算法的对比

|排序算法|时间复杂度|是否基于比较|
|:-----:|:-------:|:--------:|
|冒泡、插入、选择|O(n<sup>2</sup>)|Y|
|快排、归并|O(nlogn)|Y|
|桶、计数、基数|O(n)|N|

## 0x2 冒泡排序（Bubble Sort）

算法思想：

冒泡排序*只会操作相邻的两个数据*。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求，如果不满足就让它俩互换，重复n次，完成n个数据的排序

优化：若某次冒泡不存在数据交互，则说明已经到达完全有序，可以终止冒泡

比如：3、5、4、1、2、6，从小到大排序

|冒泡次数|冒泡后结果|是否有数据交换|
|:-----:|:-------:|:---:|
|初始状态|3 5 4 1 2 6|-|
|第1次冒泡|3 4 1 2 5 6|有|
|第2次冒泡|3 1 2 4 5 6|有|
|第3次冒泡|1 2 3 4 5 6|有|
|第4次冒泡|1 2 3 4 5 6|无，结束排序|

性能分析：

* 稳定性：冒泡过程中只有交换才会改变两个元素的前后顺序，为了保证算法的稳定性，当相邻两个元素大小相等时，我们不做交换，相同大小的数据前后顺序不会发生改变，所以是稳定的排序算法
* 空间复杂度：冒泡过程只涉及相邻元素的交换操作，只需要常量级的临时空间，所以空间复杂度是O(1)，是原地排序算法
* 时间复杂度：
    * 最好情况是已经排好序，只需要1次冒泡，时间复杂度O(n)；
    * 最坏情况是倒序排列的情况，需要进行n次冒泡，时间复杂度是O(n<sup>2</sup>)
    * 平均情况：通过有序度和逆序度分析
    
    *有序度*和*逆序度*：对于一个不完全有序的数组，如4、5、6、3、2、1，有序元素对为3个（4，5）、（4，6）和（5、6），有序度是3，逆序度是12；
    对于一个完全有序的数组，如1、2、3、4、5、6，有序度就是`n*(n-1)/2`，也就是15，称为*满有序度*；
    关于这3个概念，有一个公式：`逆序度=满有序度-有序度`，_排序的过程就是增加有序度，减少逆序度的过程，最后达到满有序度，说明排序完成_。
    
    冒泡排序包含2个操作：*比较*和*交换*，每交换一次，有序度就+1，总交换次数是确定的，即是*逆序度*，也就是`n\*(n-1)/2-初始有序度`。
    最好情况交换次数0，最坏情况交换次数n*(n-1)/2，平均情况下交换次数取两者平均值n*(n-1)/4，而比较操作肯定比交换次数多，
    而复杂度上限是O(n<sup>2</sup>)，所以平均情况的时间复杂度O(n<sup>2</sup>)
        
## 0x3 插入排序（Insertion Sort）

算法思想：

插入排序借助"往有序集合中动态地插入数据"的思路来实现排序

比如：有序集合1、7、8、13，插入6，我们只需要遍历有序数组，找到6应该插入的位置，然后把插入位置之后的数据都向后搬移，得到1、6、7、8、13


```

------------------
|1|7|8|13| | | | |  <-插入6
------------------
    \ \ \ 搬移
------------------
|1| |7|8|13| | | |  
------------------
    插入6之后
------------------
|1|6|7|8|13| | | |  
------------------
```

实现方法：把数组中数据分为2个区间，*已排序区*和*未排序区*。初始已排序区只有1个元素，就是数组的第一个元素。
核心思想是取未排序区的元素，在已排序区中找到合适的插入位置将其插入，重复这个过程，直到未排序区的元素为空，算法结束

性能分析：

* 空间复杂度：插入排序不需要额外的存储空间，空间复杂度O(1)，是原地排序
* 稳定性：对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，保存前后顺序不变，所以是稳定的排序算法
* 时间复杂度：
    * 最好情况是已经排好序，O(n)
    * 最坏情况是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，需要移动大量数据，时间复杂度O(n<sup>2</sup>)
    * 在数组中插入一个数据的平均时间复杂度是O(n)，对于插入排序来说，循环执行n次插入操作，所以平均时间复杂度是O(n<sup>2</sup>)
    
## 0x4 选择排序（Selection Sort）

算法思想：

思路和插入排序类似，也分*已排序区间*和*未排序区间*。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。

示例如下：

```
//初始状态，已排序区间为空
4 5 6 3 2 1
          ^
         min

//交换4和1，已排序区间[1]
1 5 6 3 2 4
        ^
       min
       
//交换5和2，已排序区间[1,2]
1 2 6 3 5 4
      ^
     min
//交换6和3，已排序区间[1,2,3]
1 2 3 6 5 4
          ^
         min
//交换6和4，已排序区间[1,2,3,4]
1 2 3 4 5 6
        ^
       min
//交换5自己，已排序区间[1,2,3,4,5]
1 2 3 4 5 6
          ^
         min
//交换6自己，已排序区间[1,2,3,4,5,6]，至此排序结束

```

性能分析：

* 空间复杂性：不需要额外的存储空间，空间复杂度是O(1)，是原地排序
* 时间复杂性：最好、最坏和平均情况的时间复杂度都是O(n<sup>2</sup>)
* 稳定性：选择排序每次都在未排序区间内找到最小值并和前面的元素交换位置，这样会破坏稳定性，比如：5、8、5、2、9这样一组数据，第一次找到最小值2，和第一个5交换位置，
那第一个5和中间的5顺序就变了，所以不稳定了，所以相对于冒泡和插入排序，选择排序稍微逊色

## 0x5 冒泡 vs 插入 vs 选择排序

| |是否原地排序|是否稳定|最好、最坏、平均|
|:---:|:--------:|:------:|:-------:|
|冒泡排序|Y|Y|O(n)、O(n<sup>2</sup>)、O(n<sup>2</sup>)|
|插入排序|Y|Y|O(n)、O(n<sup>2</sup>)、O(n<sup>2</sup>)|
|选择排序|Y|N|O(n<sup>2</sup>)、O(n<sup>2</sup>)、O(n<sup>2</sup>)|

## 0x6 思考

冒泡排序和插入排序时间复杂度都是O(n<sup>2</sup>)，都是原地排序，为什么插入排序要比冒泡排序更受欢迎？

//TODO

