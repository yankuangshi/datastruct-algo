# 排序(2)（Sorting）

## 0x0 归并排序（Merge Sort）

算法思想：

把要排序的数组从中间分成前后两部分，然后对前后两部分分别排序，再把排序好的两个部分合并在一起。

> 归并排序采用的是*分治思想*，将一个大问题分解成小的子问题来解决，小问题解决了大问题也就解决了

归并排序的递推公式：

```
merge_sort(p..r) = merge(merge_sort(p..q), merge_sort(q+1..r))

其中下标`q`等于`p`和`r`的中间位置，也就是`(p+r)/2`

终止条件：`p>=r`不再继续分解
```

写成伪代码就是：

```java
//归并排序，A是数组，n表示数组大小
merge_sort(A, n) {
    merge_sort_c(A, 0, n-1)
}

//递归调用函数，p和r是下标
merge_sort_c(A, p, r) {
    //递归终止条件
    if p >= r then return

    //取p到r之间的中间位置q
    q = (p+r)/2

    //分治递归
    merge_sort_c(A, p, q)
    merge_sort_c(A, q+1, r)

    //将A[p...q]和A[q+1...r]合并为A[p...r]
    merge(A[p..r], A[p..q], A[q+1..r])
```

merge函数的实现思路是：

申请一个临时数组`tmp`，大小与`A[p...r]`相同，用两个游标`i`和`j`，分别指向`A[p..q]`和`A[q+1..r]`的开头元素，
比较`A[i]`和`A[j]`，把较小的放入到`tmp`，并且将较小元素的下标后移一位，重复这个过程，直到其中一个子数组的所有元素都放入到`tmp`，再把另一个
数组的元素依次加入`tmp`的末尾，最后再把`tmp`中数据拷贝到原数组`A[p..r]`中。

示例如下：

```

A[p..r] [1 5 6 2 3 4] -> tmp []
         ^     ^
         i     j
//下标i和j的元素比较，1较小，放入tmp，i++
A[p..r] [1 5 6 2 3 4] -> tmp [1]
           ^   ^
           i   j
//下标i和j的元素比较，2较小，放入tmp，j++
A[p..r] [1 5 6 2 3 4] -> tmp [1 2]
           ^     ^
           i     j
//下标i和j的元素比较，3较小，放入tmp，j++
A[p..r] [1 5 6 2 3 4] -> tmp [1 2 3]
           ^       ^
           i       j
//下标i和j的元素比较，4较小，放入tmp，j++
A[p..r] [1 5 6 2 3 4] -> tmp [1 2 3 4]
           ^         ^
           i         j
//后半个子数组已经搬移完毕，把前半子数组剩余元素依次移入tmp
A[p..r] [1 5 6 2 3 4] -> tmp [1 2 3 4 5 6]

//把tmp拷贝回原数组
A[p..r] [1 2 3 4 5 6] <- tmp [1 2 3 4 5 6]
           
```

性能分析：

* 空间复杂度：每次合并时都需要申请额外的内存空间，最大不会超过n，所以空间复杂度是O(n)
* 稳定性：在合并过程中，如果`A[p..q]`和`A[q+1..r]`两个子数组中有相同元素，我们可以选择先把`A[p..r]`中的元素放入`tmp`数组，这样就能保证值相同的元素在合并前后先后顺序不变，
所以归并排序是稳定的排序算法
* 时间复杂度：这里涉及递归代码的时间复杂度分析
    
    定义求解问题a的时间是T(a)，求解子问题b、c的时间分别是T(b)和T(c)，那么有公式：
    
    ```
    T(a) = T(b) + T(c) + K
    ```

    K等于将子问题b、c的结果合并成问题a的结果所消耗的时间
    
    假设对n个元素归并排序需要的时间是T(n)，那分解成2个子数组排序的时间是T(n/2)，而且`merge()`函数合并两个有序子数组的时间复杂度是O(n)，所以套用上面的公式，递归排序的时间复杂度计算公式是：
    
    ```
    T(1) = C;   n=1时，只需常量级的执行时间
    T(n) = 2 * T(n/2) + n; n>1
    
    求解T(n)
    T(n) = 2 * T(n/2) + n
         = 2 * (2 * T(n/4) + n/2) + n = 4 * T(n/4) + 2n
         = 4 * (2 * T(n/8) + n/4) + 2n = 8 * T(n/8) + 3n
         ...
         = 2^k * T(n/2^k) + k * n
         
    ```
    当T(n/2^k)=T(1)时，也就是n/2^k=1，得到k=log<sub>2</sub>n，将k值带入以上公式，得到T(n)=Cn+nlog<sub>2</sub>n，所以T(n)就等于O(nlogn)
    
    归并排序的执行效率与要排序的原始数组的有序程度无关，所以不管最好、最坏还是平均情况，时间复杂度都是O(nlogn)

## 0x1 快速排序（Quick Sort）

算法思想：

待排序数组`A[p..r]`，选择`p`到`r`之间的任意一个数据作为pivot（分区点），遍历`p`到`r`之间的数据，将小于pivot的放在左边，大于pivot的放在右边，pivot放中间。
数组被分成3部分，前面`A[p..q-1]`都是小于pivot的，中间是pivot，后面`A[q+1..r]`都是大于pivot的。然后再根据*分支*的思想，用递归排序`A[p..q-1]`和`A[q+1..r]`，
直到区间缩小为1，说明排序完成。

快排的递推公式：

```
quick_sort(p..r) = quick_sort(p..q-1) + quick_sort(q+1..r)

终止条件：
p >= r
```

写成伪代码就是：

```java
//快速排序，A是数组，n表示数组大小
quick_sort(A, n) {
    quick_sort_c(A, 0, n-1)
}

//快速排序递归函数，p和r为下标
quick_sort_c(A, p, r) {
    if p >= r then return
    
    q = partition(A, p, r)  //获取pivot分区点
    quick_sort_c(A, p, q-1)
    quick_sort_c(A, q+1, r)
}
```

partition函数的实现思路：

随即选择一个元素作为pivot（一般情况下，可以选择p到r区间的最后一个元素），然后对`A[p..r]`分区，函数返回pivot下标。为了让partition函数不占用额外的内存空间，我们需要
在`A[p..r]`的原地完成分区操作，具体方法如下

处理有点类似选择排序，假设`pivot=A[r]`，通过游标`i`把`A[p..r-1]`分成2部分，`A[p..i-1]`中的元素都小于pivot，叫它"已处理区间"，`A[i..r-1]`是"未处理区间"。每次
从未处理区间`A[i..r-1]`中取一个元素`A[j]`，与pivot对比，如果小于pivot，则将其加入到已处理区间的末尾，也就是`A[i]`，但是为了避免数组中插入数据导致的数据搬移，选择将`A[i]`和`A[j]`
交换，这样就可以保证O(1)时间复杂度下内将`A[j]`放到下标为i的位置。

示例如下：

```
6 11 3 9 8 <- pivot //6<8，A[i] A[j]交换位置，已处理区[6]
^        
ij

6 11 3 9 8 <- pivot //11>8，A[i] A[j]不交换位置
  ^         
  ij
  
6 11 3 9 8 <- pivot //3<8，A[i] A[j]交换位置，已处理区[6,3]
  ^  ^        
  i  j

6 3 11 9 8 <- pivot //9>8，A[i] A[j]不交换位置
    ^  ^        
    i  j

6 3 11 9 8 <- pivot //A[i]和A[r]交换位置
    ^    ^        
    i    r

6 3 8 9 11
    ^
    pivot
```

性能分析：

* 空间复杂度：不需要额外的内存空间，O(1)，是原地排序
* 稳定性：如果数组中有2个相同元素，如6、8、7、6、3、5、9、4，经过第一次分区操作后，两个6的相对先后顺序就会改变，所以不是稳定的排序算法
* 时间复杂度：同样可以利用递归方式分析

    假设每次分区操作，都能正好把数组分成大小接近相等的2个小区间，那快排的时间复杂度递推公式如下
    
    ```
    T(1) = C; n=1时，只需要常量级的执行时间，用C表示
    T(n) = 2 * T(n/2) + n; n>1
    ```
    
    所以快排的时间复杂度也是O(nlogn)
    
    但是，公式成立的前提是分区正好把大区间对等一分为二，如果每次分区得到的两个区间极其不均等，需要进行大约n次分区才能完成快排，每次分区我们平均扫描大约n/2个元素，
    这种极端情况下，时间复杂度从O(nlogn)退化成O(n<sup>2</sup>)，但是可以通过合理地选择pivot来避免这种情况
    

## 0x2 归并 vs 快排

| |是否原地排序|是否稳定|最好、最坏、平均|
|:---:|:--------:|:------:|:-------:|
|归并排序|N|Y|O(nlogn)、O(nlogn)、O(nlogn)|
|快速排序|Y|N|O(nlogn)、O(n<sup>2</sup>)、O(nlogn)|

## 0x3 思考

如何用O(n)的时间复杂度求无序数组中的第K大元素？比如数组4、2、5、12、3，第3个元素就是4

<details>
<summary>点击展开</summary>

选取数组`A[0..n-1]`最后的元素`A[n-1]`作为pivot，将数组分成3部分，`A[0..p-1]`，`A[p]`，`A[p+1..n-1]`。如果p+1=K，那么`A[p]`就是第K大元素；
如果K>p+1，那说明第K大元素在`A[p+1..n-1]`中，再按上面的思路递归地在`A[p+1..n-1]`中查询。同理如果K<p+1，那么在`A[0..p-1]`中查询。

时间复杂度分析：

第一次分区，需要对大小为n的数组执行分区，遍历n个元素；第二次分区，只需要遍历n/2；依次类推分别为n、n/2、n/4、n/8...直到区间缩小为1

把每次分区遍历的元素个数累计得：n+n/2+n/4+n/8+...+1 = 2n-1，所以时间复杂度是O(n)

</details>