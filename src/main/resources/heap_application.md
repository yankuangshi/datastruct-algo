# 堆的应用

## 优先级队列（Priority Queue)

队列（Queue）的特点是：先进先出（FIFO）

优先级队列（Priority Queue）的特定是：按优先级高低，优先级高的先出队

可以通过堆来实现优先级队列，往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于从堆中取出堆顶元素。

### 合并有序小文件 (merge small file)

假设：100个小文件，每个文件100MB，每个文件存储着有序的字符串，我们希望把100个小文件合并成一个有序的大文件

解决思路：从100个小文件中各取出一个字符串，放入小顶堆中，堆顶的元素就是优先级队列首的元素，也就是最小字符串，然后将堆顶字符串放入到大文件中，并将其从堆中删除，然后再从小文件中取出下一个字符串放入堆中，循环整个过程

### 高性能定时器（high performance scheduler)

假设：一个定时器维护了很多定时任务，每个任务都有一个触发执行的时间点，定时器每隔一个很小的单位时间（比如1s）去扫描一遍任务，如果有任务到达执行时间，就拿出去执行，但是这种做法很低效：

    1. 万一任务的执行时间离当前时间很久，那每次扫描都是徒劳

    2. 如果整个任务列表很大，扫描会很耗时

解决思路：按照任务的执行时间，将任务存储在优先级队列中，队首（小顶堆堆顶）存储的最先要执行的任务，这样子定时器就只需要拿队首任务的执行时间和当前时间相减，

得到一个时间间隔T，定时器就可以设定在T时间之后再来执行任务，当T时间过去后，取出队首任务，再重新计算新的队首任务和当前时间点的时间间隔T'，作为下一个任务执行需要等待的时间

## 求解Top-K问题

假设：有一组数据，需要求Top K的数据集

思路：维护一个大小为K的小顶堆，先把这组数据的前K个元素插入小顶堆中，之后遍历剩下的数组，如果比堆顶元素大，就把堆顶元素删除，并且将这个元素放入堆顶，重新堆化；如果比堆顶元素小，继续遍历数组，直到遍历完成，堆中的数据就是前K大的数据

## 求中位数

假设：有一组动态数据（随时有数据插入或者删除），求这组数据的中位数数据

```
中位数：对于一组排序好的数据

[1, 2, 3, 4, 5, 6, 7]    -> 总个数n为奇数，那么第n/2+1就是中位数，4是中位数
          ^
[1, 2, 3, 4, 5, 6, 7, 8] -> 总个数n为偶数，那么第n/2和n/2+1都可以算是中位数，比如取前一个，4是中位数
          ^  ^
```

从以上例子可以看出，如果数据是一组静态数据，只需要先排序，然后按照n是奇数或者偶数就可以直接求出中位数，但是如果数据是一组动态数据，则每次有数据插入或者删除如果都进行一次先排序的操作，那么就会很低效

解决思路：维护2个堆（一个大顶堆一个小顶堆），大顶堆存储前半部分数据，小顶堆存储后半部分数据，且小顶堆数据大于大顶堆数据

例如：如果n是偶数，那么前n/2个数据存储在大顶堆中，后n/2个数据存储在小顶堆中；如果n是奇数，前n/2+1个数据存储在大顶堆，后n/2个数据存储在小顶堆；那么大顶堆的堆顶元素就是中位数。

当添加一个新数据时，如果新元素大于等于小顶堆堆顶元素，则新数据加入小顶堆，否则加入大顶堆。

随着数据的加入和删除，大顶堆和小顶堆的个数会出现失衡，也就是不再符合先前约定的n/2和n/2、或者n/2+1和n/2，这种情况就需要移动2个堆的堆顶元素来再次实现平衡。比如：

```
//中位数13

MaxHeap     MinHeap
   13      15
   /\      /\
  8  9    20 21
 /       /
7       30

//插入16

MaxHeap     MinHeap
   13      15
   /\      /\
  8  9   16 21
 /       /\
7       30 20

//不再符合大顶堆5个和小顶堆4个的规格（总个数n=9），把小顶堆堆顶数据移动到大顶堆，中位数15

MaxHeap     MinHeap
  15      16
  /\      /\
 13  9   20 21
 /\      /
7  8    30
```

### 变形问题：求K百分位(K%)数据

假设：和中位数类似的一个变形问题，求99百分位数

解决思路：方法和求中位数一样，把前99%*n个数据放入大顶堆，把后1%*n个数据放入小顶堆