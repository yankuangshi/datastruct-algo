# 排序(3) （Sorting）

## 0x0 什么是线性排序（Linear Sort）

1. 时间复杂度为O(n)，是线性的排序算法，比如：桶排序、计数排序、基数排序
2. 这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作
3. 对排序的数据要求苛刻，重点掌握这3种排序算法的适用场景

## 0x1 桶排序（Bucket Sort）

0x12 算法思想：

1. 将要排序的数据分到N个有序的桶里，每个桶里的数据再单独进行排序
2. 桶内排序完后，再把每个桶里的数据按顺序依次取出，组成的序列就是有序的

0x13 时间复杂度：

假设总共n个数据，把它们均匀分到m个桶内，每个桶k=n/m个元素。每个桶内使用快排，时间复杂度是O(k*logk)。m个桶排序的时间复杂度就是O(m*k*logk),
把k=n/m代入得O(n*log(n/m))，当桶的个数m接近数据总数n时，log(n/m)就是个非常小的常量，此时的桶排序的时间复杂度接近O(n)

0x14 使用条件：

1. 要排序的数据需要很容易划分到m个桶，且桶和桶之间有天然的大小顺序
2. 数据在各个桶之间的分布要比较均匀，如果不均匀，比如极端情况下，数据都被分到一个桶里，那就退化成O(nlogn)的排序算法了

0x15 适用场景：

桶排序适用在外部排序，就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

0x16 应用案例：

举个栗子：有100GB的订单数据，希望按订单金额排序，但是内存有限，只有几百MB，没办法一次性把100GB的数据加载入内存

解决思路：

先扫描一遍所有订单，看订单金额的范围，假设扫描后发现金额最小1元，最大10万元，我们将所有订单根据金额划分到100个桶里，每个桶的金额范围依次为：
1~1000元、1001~2000元、...、99001~100000元，把每个桶按金额范围大小顺序编号为00，01，02，..99。

理想情况下，如果订单金额在1-10万之间是均匀分布，那订单可以被均匀划分到100个文件中，每个文件存储大约100MB的订单数据，这样就可以把100个小文件依次放入
内存中用快排排序。等所有文件排序好后只有按文件编号从小到大读取每个小文件中的数据即可。

但是万一划分不均匀，划分之后对应的文件还是很大，没法一次性读入内存，那么可以针对划分之后还是比较大的文件，继续划分。

## 0x2 计数排序（Counting Sort）

0x21 算法思想：

*计数排序其实是桶排序的一种特殊情况*，当要排序的n个数据，所处的范围并不大，比如最大值为k，我们可以把数据划分到k个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间。

0x22 实现方法及应用案例：

举个栗子：假设8个考生，分数在0-5之间，考生的成绩放在数组`A[8]`中，分别是2、5、3、0、2、3、0、3

另一个数组`C[6]`来存储每个分数下的考生的个数（数组下标为分数），结果是`C[6] = [2,0,2,3,0,1]`，0分有2个，1分为0个，2分有2个...，以分数为3为例，
小于3分的学生有4个，分数为3分的有3个，所以分数为3的学生在排序之后的有序数组`R[8]`中，会保存在下标为4，5，6的位置

```
         -----------------
数组R[8]：| | | | |3|3|3| |
         -----------------
下标：     0 1 2 3 4 5 6 7
```

如何快速计算出每个分数的考试在有序数组中对应的存储位置，思路是：对`C[6]`数组顺序求和

```
         ------------
数组C[6] |2|2|4|7|7|8|
         ------------
下标      0 1 2 3 4 5

```

`C[k]`里的数据表示小于等于分数k的考试个数

从后往前遍历数组`A[8]=[2,5,3,0,2,3,0,3]`，比如当扫描到3时，`C[3]=7`说明到目前为止，包括自己在内，分数小于等于3的考试有7个，也就是说3是数组`R`中的第7个元素（下标为6），
当3放入数组`R`后，小于等于3的元素就少了一个，所以相应的`C[3]`要减1，变成6。

示例如下：

```
A[8]=[2,5,3,0,2,3,0,3]

//把3放入R，C[3]减1
数组R[8] | | | | | | |3| |    C[6] |2|2|4|6|7|8|
         ----------------          ------------
下标      0 1 2 3 4 5 6 7           0 1 2 3 4 5

//把0放入R，C[0]减1
         ----------------          ------------
数组R[8] | |0| | | | |3| |    C[6] |1|2|4|6|7|8|
         ----------------          ------------
下标      0 1 2 3 4 5 6 7           0 1 2 3 4 5

//把3放入R，C[3]减1
数组R[8] | |0| | | |3|3| |    C[6] |1|2|4|5|7|8|
         ----------------          ------------
下标      0 1 2 3 4 5 6 7           0 1 2 3 4 5

//把2放入R，C[2]减1
数组R[8] | |0| |2| |3|3| |    C[6] |1|2|3|5|7|8|
         ----------------          ------------
下标      0 1 2 3 4 5 6 7           0 1 2 3 4 5

//把0放入R，C[0]减1
数组R[8] |0|0| |2| |3|3| |    C[6] |0|2|3|5|7|8|
         ----------------          ------------
下标      0 1 2 3 4 5 6 7           0 1 2 3 4 5

//把3放入R，C[3]减1
数组R[8] |0|0| |2|3|3|3| |    C[6] |0|2|3|4|7|8|
         ----------------          ------------
下标      0 1 2 3 4 5 6 7           0 1 2 3 4 5

//把5放入R，C[5]减1
数组R[8] |0|0| |2|3|3|3|5|    C[6] |0|2|3|4|7|7|
         ----------------          ------------
下标      0 1 2 3 4 5 6 7           0 1 2 3 4 5

//把2放入R，C[2]减1
数组R[8] |0|0|2|2|3|3|3|5|    C[6] |0|2|2|4|7|7|
         ----------------          ------------
下标      0 1 2 3 4 5 6 7           0 1 2 3 4 5
```

0x23 适用场景：

1. 只能用在数据范围不大的场景，如数据范围k比要排序的数据n大很多，那就不适用计数排序
2. 计数排序只能给非负整数排序，如果排序数据有负，要将其在不改变相对大小的情况下，转化为非负整数，
    
    比如如果考试分数精确到小数后1位，就需要将所有分数乘以10，转化为整数

## 0x3 基数排序（Radix Sort）

0x31 算法思想（以排序10万个手机号为例）：

1. 比较2个手机号a，b的大小，如果数据a中的高位已经比b大了，那剩余的后面几位就不用看了
2. 借助稳定排序算法的思想，先按照最后1位来排序手机号，然后再按照倒数第二位重新排序，依次类推，最后按照第一位重新排序
    
    每次排序有序数据范围较小（手机号数字0~9），可以使用桶排序或者计数排序
    
0x32 使用条件：

1. 排序的数据可以分割出独立的"位"来比较
2. 而且位之间有递进的关系，如果数据a的高位比数据b大，那么剩下的低位就不用比较了
3. 每一位的数据范围不能太大，要可以用线性排序算法来排序，否则基数排序的时间复杂度就无法做到O(n)

## 0x4 思考

如何根据年龄给100万用户排序

<details>
<summary>点击展开</summary>
可以假设年龄范围最小是1岁，最大不超过120岁，遍历100万用户，根据年龄将其划分到120个桶里，然后依次顺序遍历120个桶中的元素
</details>
    
    



