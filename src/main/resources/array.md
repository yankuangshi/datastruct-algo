# 数组（Array）

数组是一种*线性表*数据结构，它用一组*连续的内存空间*来存储一组具有*相同类型的数据*，数组具有以下特征：

1. 线性表（Linear List）：线性表上的数据最多只有前后2个方向，类似的数据结构还有链表（List）、队列（Queue）、栈（Stack），与此概念相对的是非线性表，比如树（Tree）、堆（Heap）、图（Graph）等
2. 连续的内存空间和相同类型的数据
    
## 数组如何实现随机访问

数组在内存中申请的是一组连续的内存空间、只能用于存储相同类型的数据，所以数组可以随机访问

例如，当`int[] a = new int[10]`，会在内存中申请一片连续内存空间：

|idx|a[10]|addr|
|:---:|:---:|:---:|
| 0 | a[0]|1000~1003|
| 1 | a[1]|1004~1007|
| 2 | a[2]|1008~1011|
|...| ... |  ...    |
| 9 | a[9]|1036~1039|

我们可以很容易地根据数组的起始地址和数组元素占的字节数计算出第i个元素的内存地址：`ith_element_addr = base_addr + i * data_type_size`，比如以上例子中int数据类型占4个字节

> 这里要纠正一个"错误"，数组的查找时间复杂度是O(1)，这种表述不准确，即使是排好序的数组，用二分法查找，时间复杂度也是O(logn)，
所以正确的表述应该是：数组支持随机访问，根据下标随机访问的时间复杂度是O(1)

## 数组低效的"插入"和"删除"

### 插入

插入的最好情况是插入到末尾，时间复杂度是O(1)；最坏情况是插入到开头，则需要把所有的元素向后移一位，时间复杂度是O(n)；由于每个位置插入的概率一样，所以平均情况的时间复杂度为
(1+2+..n)/n=O(n)

### 删除

删除的最好情况是删除末尾元素，时间复杂度是O(1)；最坏情况是删除开头，则需要把所有的元素向前移一位，时间复杂度是O(n)；平均情况的时间复杂度也是O(n)

> 提高效率：为了优化删除的效率，可以把删除的元素标记为删除，等数组没有更多存储空间时再触发一次真正的删除和数据搬移，这种方法也是JVM中GC标记删除算法的核心思想

## 警惕数组的访问越界

像Java本身会做数组的越界检查，一旦越界会抛出`java.lang.ArrayIndexOutOfBoundsException`

## 容器能否代替数组

例如Java中的ArrayList容器能否来代替数组？

ArrayList的优势：相比于数组，ArrayList封装了数组的很多操作，包括插入、删除时需要的数据搬移，并且支持*动态扩容*

数组适合的场景：

1. Java ArrayList中对基本类型（int、long等）封装成了Integer、Long等，装箱和拆箱过程会有一定性能损坏，如果希望存储基本类型或者特别关注性能，可以考虑数组
2. 如果事先知道数据大小，并且数据操作简单，可以使用数组
3. 表示多维数组时，数组更直观
4. 业务开发，直接使用容器更方便；如果是底层开发，如网络框架，为了性能方面的考量，选择数组

## 思考：为什么数组从0开始编号，不是从1

1. 由于数组通过寻址公式计算出元素i的内存地址`a[i]_addr = base_addr + i * data_type_size`，如果从1开始，寻址公式就变成`a[i]_addr = base_addr + (i-1) * data_type_size`
对于CPU来说多了一条减法指令
2. 历史原因

## 二维数组的寻址公式

二维数组本质上也是一个连续内存地址的一维数组，所以假设二维数组是`m*n`，则`a[i][j]_addr = base_addr + (i*n+j) * data_type_size`

## 数组相关代码练习

* 实现一个支持动态扩容的数组 
* 实现一个大小固定的有序数组
* 实现两个有序数组合并为一个有序数组

LeetCode练习题：

* Two Sum（两数之和）
* Three Sum（三数之和）
* Majority Element（在数组中出现次数超过一半的数）
* FizzBuzz（3 和 5 的倍数）
* Merge Sorted Array（合并两个有序数组）
* First Missing Positive（寻找缺失的最小正数）
* Kth Largest Element in an Array（查找第K大的数）
* Single Number（数组中只出现一次的数）
* Find All Duplicates in an Array（数组中重复的数字）