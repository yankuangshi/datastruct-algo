# 数组（Array）

数组是一种*线性表*数据结构，它用一组*连续的内存空间*来存储一组具有*相同类型的数据*，数组具有以下特征：

    1. 线性表（Linear List）：线性表上的数据最多只有前后2个方向，类似的数据结构还有链表（List）、队列（Queue）、栈（Stack），
       于此概念相对于的是非线性表，比如树（Tree）、堆（Heap）、图（Graph）等
    2. 连续的内存空间和相同类型的数据
    
## 数组如何实现随机访问

数组在内存中申请的是一组连续的内存空间、只能用于存储相同类型的数据，所以数组可以随机访问

例如，当`int[] a = new int[10]`，会在内存中申请一片连续内存空间：

|idx|a[10]|addr|
|:---:|:---:|:---:|
| 0 | a[0]|1000~1003|
| 1 | a[1]|1004~1007|
| 2 | a[2]|1008~1011|
|...| ... |  ...    |
| 9 | a[9]|1036~1039|

我们可以很容易地根据数组的起始地址和数组元素占的字节数计算出第i个元素的内存地址：`ith_element_addr = base_addr + i * data_type_size`，比如以上例子中int数据类型占4个字节

> 这里要纠正一个"错误"，数组的查找时间复杂度是O(1)，这种表述不准确，即使是排好序的数组，用二分法查找，时间复杂度也是O(logn)，
所以正确的表述应该是：数组支持随机访问，根据下标随机访问的时间复杂度是O(1)

## 数组低效的"插入"和"删除"

### 插入

插入的最好情况是插入到末尾，时间复杂度是O(1)；最坏情况是插入到开头，则需要把所有的元素向后移一位，时间复杂度是O(n)；由于每个位置插入的概率一样，所以平均情况的时间复杂度为
(1+2+..n)/n=O(n)

### 删除

删除的最好情况是删除末尾元素，时间复杂度是O(1)；最坏情况是删除开头，则需要把所有的元素向前移一位，时间复杂度是O(n)；平均情况的时间复杂度也是O(n)

> 提高效率：为了优化删除的效率，可以把删除的元素标记为删除，等数组没有更多存储空间时再触发一次真正的删除和数据搬移，这种方法也是JVM中GC标记删除算法的核心思想

## 警惕数组的访问越界

像Java本身会做数组的越界检查，一旦越界会抛出`java.lang.ArrayIndexOutOfBoundsException`

## 容器能否代替数组

例如Java中的ArrayList容器能否来代替数组？

ArrayList的优势：相比于数组，ArrayList封装了数组的很多操作，包括插入、删除时需要的数据搬移，并且支持*动态扩容*

数组适合的场景：

1. Java ArrayList中对基本类型（int、long等）封装成了Integer、Long等，装箱和拆箱过程会有一定性能损坏，如果希望存储基本类型或者特别关注性能，可以考虑数组
2. 如果事先知道数据大小，并且数据操作简单，可以使用数组
3. 表示多维数组时，数组更直观
4. 业务开发，直接使用容器更方便；如果是底层开发，如网络框架，为了性能方面的考量，选择数组

