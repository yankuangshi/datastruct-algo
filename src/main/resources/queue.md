# 队列（Queue）

## 0x0 什么是"队列"
1. 队列的特征，*先进者先出（FIFO：FIRST IN FIRST OUT）*
2. 和栈一样，队列也是一种*操作受限的线性表数据结构*

## 0x1 队列的应用

一些具有额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层的系统、框架、中间件的开发中起着关键性作用。
比如，Disruptor、Linux环形缓存都用到了循环并发队列；Java concurrent并发包利用ArrayBlockingQueue实现公平锁

## 0x2 实现一个"队列"

最基本的2个操作：

1. 入队（enqueue）：放一个数据到队尾
2. 出队（dequeue）：从队列头部取出一个数据

队列的API：

```java
public class Queue<T> {
    public void enqueue(T data);
    public T dequeue();
    public int size();
    public boolean isEmpty();
}
```

和栈一样，队列也可以用数组和链表来分别实现：

* 数组实现的队列：顺序队列
* 链表实现的队列：链式队列

### 0x21 顺序队列的实现

比起栈的实现只需要一个栈顶指针，队列需要两个指针：一个head指针，一个tail指针

示例如下：

```
//元素a、b、c、d依次入队，head指向下标0，tail指向下标4

     head=0  tail=4
       ￬       ￬
       ------------
队列： |a|b|c|d| | |
       ------------
下标：  0 1 2 3 4 5

//调用2次出队操作（a和b出队），head指向下标2，tail依然指向下标4

        head=2 tail=4
           ￬   ￬
       ------------
队列： | | |c|d| | |
       ------------
下标：  0 1 2 3 4 5
```

以上示例有个问题，随着不停的入队出队，head和tail指针都会向后移动，当tail移动到最右，即使数组有空闲空间，也无法继续往队列里添加数据

为了解决这个问题，如果让每次出队操作都进行一次数据搬移势必导致出队的时间复杂度从O(1)变为O(n)，所以可以改变一下思路，当没有空闲空间时，只需要在
入队时，再集中触发一次数据搬移

示例如下：

```
//当tail指针移动到数组的最右边后，有新元素i入队，可以将head到tail之间的数据整体搬移到数组0到tail-head的位置

           head      tail
             ￬         ￬
       ----------------
队列： | | | |d|e|f|g|h|   <- 入队i
       ----------------
下标：  0 1 2 3 4 5 6 7
             /       /
       head /       / tail
         ￬ /       / ￬
         ----------------
队列：   |d|e|f|g|h|i| | |
         ----------------
下标：    0 1 2 3 4 5 6 7
```

### 0x22 链式队列的实现

同样需要2个指针：head和tail，分别指向链表第一个和最后一个节点。

入队时 `tail->next = new_node，tail = tail->next`

出队时 `head = head->next`

示例如下：

```
     head                                     tail
      ￬                                         ￬
  ----------    ----------    ----------    ----------
  | a |next| -> | b |next| -> | c |next| -> | d |next| -> NULL
  ----------    ----------    ----------    ----------
  
//入队e
//new_node = e
//tail->next = new_node
//tail = tail->next

     head                                                   tail
      ￬                                                       ￬
  ----------    ----------    ----------    ----------    ----------
  | a |next| -> | b |next| -> | c |next| -> | d |next| -> | e |next| -> NULL
  ----------    ----------    ----------    ----------    ----------

//出队a
//head = head->next

                  head                                      tail
                    ￬                                         ￬
                ----------    ----------    ----------    ----------
                | b |next| -> | c |next| -> | d |next| -> | e |next| -> NULL
                ----------    ----------    ----------    ----------
                                 

```

### 0x23 循环队列的实现

顺序队列中，当tail==n时，会有数据搬移，为了避免数据搬移，我们可以使用循环队列

顾名思义，循环队列就是把原本是一条直线的数组头尾相连，扳成一个环：

![循环队列](img/circular_queue1.jpg)

Fig.1：队列大小为8，当前head=4，tail=7，图来自于极客时间

当一个新元素a入队，把a放入下标为7的位置，但是并不把tail更新为8，而且将其在环中后移一位，到下标0位置

![循环队列](img/circular_queue2.jpg)

Fig.2：a、b依次入队，图来自于极客时间

### 0x24 循环队列如何判断队空和队满？

![循环队列](img/circular_queue3.jpg)
Fig.3：循环队列队满的情况，图来自于极客时间

从上图可以总结规律，队满时满足：`(tail+1)%n=head`，而且队满时tail指向的空间其实是没有存储数据的，所以循环队列会浪费一个数组的存储空间

> 队满判断表达式的推导：一般情况下队满满足tail+1=head（比如上图中tail下标为3，head下标为4），但是有一种特殊情况，当tail=n-1，head=0时
  tail+1=n，所以(tail+1)%n==n%n==0，而且tail+1最大的情况就是n，除了最大情况外，tail+1怎么余n都是tail+1本身，也就是head，所以
  `(tail+1)%n=head`就是队满的表达式

## 0x3 阻塞队列和并发队列

* 阻塞队列：在队列的基础上增加阻塞操作，队空的时候，从队头取数据会被阻塞，因为没有数据可以取，之道队列中有数据才会返回；队满的时候，入队操作会被阻塞，
直到队列有空闲位置再插入数据

    阻塞队列其实就是一个"生产者-消费者"模型，可以有效协调生产和消费速度；而且基于阻塞队列，还可以通过协调"生产者"和"消费者"个数来提高数据处理效率，
    比如：配置多个"消费者"来对应一个"生产者"。

* 并发队列：线程安全的队列叫做并发队列，最简单的实现方法是在`enqueue()`和`dequeue()`方法上加锁，但是锁粒度大并发度会比较低，同时仅运行一个存或者取的操作。
基于数组的循环队列利用CAS原子操作可以实现很高效的并发队列，这也是循环队列比链式队列应用更广泛的原因。

## 0x4 思考

线程池没有空闲线程时，新的任务请求线程资源该如何处理？

两种策略处理：第一种非阻塞的方式，直接拒绝请求；第二种，阻塞的方式，将请求排队，等到有线程空闲的时候，取出排队的请求继续处理

顺序队列 vs 链式队列

链式队列是一个支持无限排队的无界队列（unbounded queue），但可能会导致过多的请求排队，请求处理的响应时间过长，所以针对响应时间敏感的系统，基于链式队列实现的线程池不适合。

顺序队列实现的是有界队列（bounded queue），队列大小有限，所以当排队的请求超过队列大小时，接下来的请求会被拒绝，对于响应时间敏感的系统更适合

## 0x5 队列相关代码练习

* 设计循环双端队列 [LeetCode 641](https://leetcode-cn.com/problems/design-circular-deque/)
* 滑动窗口最大值 [LeetCode 239](https://leetcode-cn.com/problems/sliding-window-maximum/)